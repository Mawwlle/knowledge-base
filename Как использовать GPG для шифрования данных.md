## Первоисточники
https://yanhan.github.io/posts/2017-09-27-how-to-use-gpg-to-encrypt-stuff/
https://habr.com/ru/articles/358182/
## Поехали
Когда я это пишу, я хочу создать безопасное хранилище для моих данных. Я хочу сохранять ключи и пароли на гитхабе. Он приватный (ну прям реально), но как-то это.... недостаточно секьюрно. Поэтому будет круто зашифровать это всё (заодно зашифрую свои ssh ключи)

> [!info]- Немного теории с хабра
> GPG (также известный как GnuPG) создавался как свободная альтернатива несвободному PGP. GPG используется для шифрования информации и предоставляет различные алгоритмы (RSA, DSA, AES и др.) для решения этой задачи.
> GPG может использоваться для симметричного шифрования, но в основном программа используется для ассиметричного шифрования информации. Если кратко — при симметричном шифровании для шифровки и расшифровки сообщения используется один ключ (например, какой символ соответствует той или иной букве)
> При ассиметричном шифровании используются 2 ключа — публичный и приватный. Публичный используется для шифрования и его мы можете дать своим друзьям, а приватный — для расшифровки, и его вы должны хранить в безопасности. Благодаря такой схеме расшифровать сообщение может только владелец приватного ключа (даже тот, кто зашифровывал сообщение, не может произвести обратную операцию). Подробнее про асимметричное шифрование вы можете прочитать в [Википедии](https://ru.wikipedia.org/wiki/%D0%9A%D1%80%D0%B8%D0%BF%D1%82%D0%BE%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D0%B0_%D1%81_%D0%BE%D1%82%D0%BA%D1%80%D1%8B%D1%82%D1%8B%D0%BC_%D0%BA%D0%BB%D1%8E%D1%87%D0%BE%D0%BC).
> 

Обзор шагов выглядит следующим образом:

1. Сделаем единый файл. Если файлов несколько, создать архив этой папки, или просто напрямую tarball всех файлов
2. (НЕОБЯЗАТЕЛЬНО) В идеале, можно подписать файл, используя **закрытый ключ**.
3. **Зашифруйте файл, используя открытый ключ** получателя . Это создаст зашифрованный файл, который можно будет расшифровать только с помощью закрытого ключа получателя.
4. Отправьте зашифрованный файл и (по желанию) подпись другому человеку.
5. Получатель сообщения расшифрует зашифрованный файл, используя свой закрытый ключ.
6. (НЕОБЯЗАТЕЛЬНО) Получатель сообщения проверит подпись, используя ваш открытый ключ.

## Шаг 1: Создайте пару ключей GPG
```shell
gpg --gen-key
```
Пройдя небольшой опросик (какая пара ключей вообще создаётся). Будет довольно долгий процесс создания ключей. Нужно обязательно выставить парольную фразу и немного подождать.
[Эта запись в блоге LastPass](https://blog.lastpass.com/2013/04/how-to-create-secure-master-password.html/) является хорошим руководством по созданию хорошей парольной фразы.

```
We need to generate a lot of random bytes. It is a good idea to perform
some other action (type on the keyboard, move the mouse, utilize the
disks) during the prime generation; this gives the random number
generator a better chance to gain enough entropy.

Not enough random bytes available.  Please do some other work to give
the OS a chance to collect more entropy! (Need _ more bytes)
```

## Шаг 2 (для отправителя): Создать публичный ключ
```shell
gpg --armor --output some_pub_key.gpg --export your.name@yourdomain.com
```
Где, your.name@yourdomain.com - адрес почты, который нужно было ввести
## Шаг 3 (для получателя): Получить публичный ключ
```shell
gpg --import some_pub_key.gpg
```
## Шаг 4 (для отправителя): 
```shell
gpg --output myfile.txt.gpg --encrypt --recipient your.friend@yourfriendsdomain.com  myfile.txt
```

> [!warning]
Если отправитель и получатель - один человек, то `--recipient` можно не делать

### Шаг 5 (для отправителя) - создание подписи (НЕОБЯЗАТЕЛЬНО):
**ПРИМЕЧАНИЕ:** Этот шаг необязателен. Причина, по которой вы как отправитель можете захотеть подписать сообщение, заключается в том, что получатель должен убедиться, что это действительно вы отправили сообщение, а не кто-то другой. Это форма защиты от несанкционированного доступа.

Вместо того чтобы подписывать сообщение (что также является формой шифрования сообщения), мы сгенерируем контрольную сумму сообщения и подпишем ее.

Давайте сгенерируем сумму SHA256 **незашифрованного** файла (предположим, что он называется `myfile.txt`) и подпишем его, используя наш **закрытый ключ** :

```bash
shasum -a 256 myfile.txt | awk '{print $1}' >myfile.txt.sha256sum
gpg --output myfile.txt.sha256sum.sig --sign myfile.txt.sha256sum
```

Затем вы можете отправить его `myfile.txt.sha256sum.sig`получателю.
## Шаг 6: (Для получателя) Расшифруйте сообщение.

Предположим, что зашифрованное сообщение, отправленное отправителем, вызывается `myfile.txt.gpg`и было зашифровано с использованием вашего открытого ключа.

Чтобы расшифровать это сообщение с помощью вашего закрытого ключа, выполните:

```bash
gpg --output myfile.txt --decrypt myfile.txt.gpg
```

Вам будет предложено ввести парольную фразу вашего закрытого ключа. Если отправитель указал получателя сообщения с помощью `--recipient`опции при шифровании сообщения, GPG должен быть в состоянии определить правильный закрытый ключ для использования (если у вас есть несколько пар ключей).

Теперь у вас есть сообщение! Оно находится в файле, указанном флагом `--output`. Если отправитель не предоставил подпись и вы доверяете ему/ей, то все готово. В противном случае перейдите к следующему шагу для проверки подписи.

## Шаг 7: (Для получателя) Проверьте подпись сообщения.

Предположим, что подпись имеет имя `myfile.txt.sha256sum.sig`. Чтобы убедиться, что подпись действительно отправлена ​​отправителем, выполните следующую команду:

```bash
gpg --verify myfile.txt.sha256sum.sig
```

Вы должны увидеть вывод, подобный следующему:

```
gpg: Signature made Tue 26 Sep 2017 09:10:22 PM SGT
gpg:                using RSA key ID 741A869EBC910BE2
gpg: Good signature from "Sender's name <sender.name@sendersdomain.com>" [unknown]
gpg: WARNING: This key is not certified with a trusted signature!
gpg:          There is no indication that the signature belongs to the owner.
Primary key fingerprint: 85AF 5410 058C FE1D 76DA  986F 910C B963 468A 0F16
```

Проверьте, что идентификатор открытого ключа и отпечаток пальца совпадают с идентификатором открытого ключа отправителя в вашей связке ключей. Запустите, `gpg --list-keys --keyid-format LONG --fingerprint`чтобы вывести список открытых ключей в вашей связке ключей GPG вместе с их отпечатком пальца.

Чтобы получить фактическое содержимое подписи, выполните:

```bash
gpg --output myfile.txt.sha256sum  --decrypt myfile.txt.sha256sum.sig
```

Вы должны увидеть вывод, очень похожий на тот, что был получен при запуске команды `gpg --verify myfile.txt.sha256sum.sig`.

Вам следует убедиться, что сумма sha256 внутри `myfile.txt.sha256sum`совпадает с суммой sha256 расшифрованного файла, который отправитель вам отправил.


# Для моего случая
1. Создаём папку ~/.ssecure (super secure -> ssecure)
2. Создаём приватный репозиторий .ssecure
3. Добавляем туда папки и файлы которые нужно зашифровать
Допустим, что-то такое
```shell
ls -la
total 16
drwxr-xr-x@  4 mawwlle  staff   128 Jan  7 16:56 .
drwxr-x---+ 49 mawwlle  staff  1568 Jan  7 16:56 ..
-rw-r--r--@  1 mawwlle  staff    45 Jan  7 16:55 ssh.txt
-rw-r--r--@  1 mawwlle  staff    88 Jan  7 16:56 ssh_key.txt
```
4. Читаем верхнее и создаём ключик (если не создано)
5. Создаём публичный ключ который складываем в репозиторий
```shell
gpg --armor --output some_pub_key.gpg --export your.name@yourdomain.com
```
6. Шифруем
7. Расшифруем (!лучше скопировать файл в домашнюю директорию, расшифровать и всо)
8. Убираем все незашифрованные файлы и пушим в репозиторий!
9. Забекапим приватный ключ!
```shell
gpg --armor --output private.gpg --export-secret-key your.name@yourdomain.com
```